// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// V1MachineIssuesRequest v1 machine issues request
//
// swagger:model v1.MachineIssuesRequest
type V1MachineIssuesRequest struct {

	// allocation hostname
	AllocationHostname string `json:"allocation_hostname,omitempty" yaml:"allocation_hostname,omitempty"`

	// allocation image id
	AllocationImageID string `json:"allocation_image_id,omitempty" yaml:"allocation_image_id,omitempty"`

	// allocation name
	AllocationName string `json:"allocation_name,omitempty" yaml:"allocation_name,omitempty"`

	// allocation project
	AllocationProject string `json:"allocation_project,omitempty" yaml:"allocation_project,omitempty"`

	// allocation role
	AllocationRole string `json:"allocation_role,omitempty" yaml:"allocation_role,omitempty"`

	// allocation succeeded
	AllocationSucceeded bool `json:"allocation_succeeded,omitempty" yaml:"allocation_succeeded,omitempty"`

	// disk names
	DiskNames []string `json:"disk_names" yaml:"disk_names"`

	// disk sizes
	DiskSizes []int64 `json:"disk_sizes" yaml:"disk_sizes"`

	// fru board mfg
	FruBoardMfg string `json:"fru_board_mfg,omitempty" yaml:"fru_board_mfg,omitempty"`

	// fru board mfg serial
	FruBoardMfgSerial string `json:"fru_board_mfg_serial,omitempty" yaml:"fru_board_mfg_serial,omitempty"`

	// fru board part number
	FruBoardPartNumber string `json:"fru_board_part_number,omitempty" yaml:"fru_board_part_number,omitempty"`

	// fru chassis part number
	FruChassisPartNumber string `json:"fru_chassis_part_number,omitempty" yaml:"fru_chassis_part_number,omitempty"`

	// fru chassis part serial
	FruChassisPartSerial string `json:"fru_chassis_part_serial,omitempty" yaml:"fru_chassis_part_serial,omitempty"`

	// fru product manufacturer
	FruProductManufacturer string `json:"fru_product_manufacturer,omitempty" yaml:"fru_product_manufacturer,omitempty"`

	// fru product part number
	FruProductPartNumber string `json:"fru_product_part_number,omitempty" yaml:"fru_product_part_number,omitempty"`

	// fru product serial
	FruProductSerial string `json:"fru_product_serial,omitempty" yaml:"fru_product_serial,omitempty"`

	// hardware memory
	HardwareMemory int64 `json:"hardware_memory,omitempty" yaml:"hardware_memory,omitempty"`

	// id
	ID string `json:"id,omitempty" yaml:"id,omitempty"`

	// ipmi address
	IpmiAddress string `json:"ipmi_address,omitempty" yaml:"ipmi_address,omitempty"`

	// ipmi interface
	IpmiInterface string `json:"ipmi_interface,omitempty" yaml:"ipmi_interface,omitempty"`

	// ipmi mac address
	IpmiMacAddress string `json:"ipmi_mac_address,omitempty" yaml:"ipmi_mac_address,omitempty"`

	// ipmi user
	IpmiUser string `json:"ipmi_user,omitempty" yaml:"ipmi_user,omitempty"`

	// defines the last error threshold
	// Required: true
	LastErrorThreshold *int64 `json:"last_error_threshold" yaml:"last_error_threshold"`

	// name
	Name string `json:"name,omitempty" yaml:"name,omitempty"`

	// network asns
	NetworkAsns []int64 `json:"network_asns" yaml:"network_asns"`

	// network destination prefixes
	NetworkDestinationPrefixes []string `json:"network_destination_prefixes" yaml:"network_destination_prefixes"`

	// network ids
	NetworkIds []string `json:"network_ids" yaml:"network_ids"`

	// network ips
	NetworkIps []string `json:"network_ips" yaml:"network_ips"`

	// network prefixes
	NetworkPrefixes []string `json:"network_prefixes" yaml:"network_prefixes"`

	// network vrfs
	NetworkVrfs []int64 `json:"network_vrfs" yaml:"network_vrfs"`

	// nics mac addresses
	NicsMacAddresses []string `json:"nics_mac_addresses" yaml:"nics_mac_addresses"`

	// nics names
	NicsNames []string `json:"nics_names" yaml:"nics_names"`

	// nics neighbor mac addresses
	NicsNeighborMacAddresses []string `json:"nics_neighbor_mac_addresses" yaml:"nics_neighbor_mac_addresses"`

	// nics neighbor names
	NicsNeighborNames []string `json:"nics_neighbor_names" yaml:"nics_neighbor_names"`

	// nics neighbor vrfs
	NicsNeighborVrfs []string `json:"nics_neighbor_vrfs" yaml:"nics_neighbor_vrfs"`

	// nics vrfs
	NicsVrfs []string `json:"nics_vrfs" yaml:"nics_vrfs"`

	// a list of machine issues to omit
	// Required: true
	Omit []string `json:"omit" yaml:"omit"`

	// a list of machine issues to include
	// Required: true
	Only []string `json:"only" yaml:"only"`

	// partition id
	PartitionID string `json:"partition_id,omitempty" yaml:"partition_id,omitempty"`

	// rackid
	Rackid string `json:"rackid,omitempty" yaml:"rackid,omitempty"`

	// filters issue for given severity
	// Required: true
	Severity *string `json:"severity" yaml:"severity"`

	// sizeid
	Sizeid string `json:"sizeid,omitempty" yaml:"sizeid,omitempty"`

	// state value
	// Enum: ["","LOCKED","RESERVED"]
	StateValue string `json:"state_value,omitempty" yaml:"state_value,omitempty"`

	// tags
	Tags []string `json:"tags" yaml:"tags"`
}

// Validate validates this v1 machine issues request
func (m *V1MachineIssuesRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLastErrorThreshold(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOmit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOnly(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *V1MachineIssuesRequest) validateLastErrorThreshold(formats strfmt.Registry) error {

	if err := validate.Required("last_error_threshold", "body", m.LastErrorThreshold); err != nil {
		return err
	}

	return nil
}

func (m *V1MachineIssuesRequest) validateOmit(formats strfmt.Registry) error {

	if err := validate.Required("omit", "body", m.Omit); err != nil {
		return err
	}

	return nil
}

func (m *V1MachineIssuesRequest) validateOnly(formats strfmt.Registry) error {

	if err := validate.Required("only", "body", m.Only); err != nil {
		return err
	}

	return nil
}

func (m *V1MachineIssuesRequest) validateSeverity(formats strfmt.Registry) error {

	if err := validate.Required("severity", "body", m.Severity); err != nil {
		return err
	}

	return nil
}

var v1MachineIssuesRequestTypeStateValuePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["","LOCKED","RESERVED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		v1MachineIssuesRequestTypeStateValuePropEnum = append(v1MachineIssuesRequestTypeStateValuePropEnum, v)
	}
}

const (

	// V1MachineIssuesRequestStateValueEmpty captures enum value ""
	V1MachineIssuesRequestStateValueEmpty string = ""

	// V1MachineIssuesRequestStateValueLOCKED captures enum value "LOCKED"
	V1MachineIssuesRequestStateValueLOCKED string = "LOCKED"

	// V1MachineIssuesRequestStateValueRESERVED captures enum value "RESERVED"
	V1MachineIssuesRequestStateValueRESERVED string = "RESERVED"
)

// prop value enum
func (m *V1MachineIssuesRequest) validateStateValueEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, v1MachineIssuesRequestTypeStateValuePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *V1MachineIssuesRequest) validateStateValue(formats strfmt.Registry) error {
	if swag.IsZero(m.StateValue) { // not required
		return nil
	}

	// value enum
	if err := m.validateStateValueEnum("state_value", "body", m.StateValue); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this v1 machine issues request based on context it is used
func (m *V1MachineIssuesRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *V1MachineIssuesRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *V1MachineIssuesRequest) UnmarshalBinary(b []byte) error {
	var res V1MachineIssuesRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
