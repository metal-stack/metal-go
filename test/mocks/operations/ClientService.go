// Code generated by mockery v2.7.4. DO NOT EDIT.

package operations

import (
	runtime "github.com/go-openapi/runtime"
	operations "github.com/metal-stack/metal-go/client/operations"
	mock "github.com/stretchr/testify/mock"
)

// ClientService is an autogenerated mock type for the ClientService type
type ClientService struct {
	mock.Mock
}

// AbortReinstallMachine provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AbortReinstallMachine(params *operations.AbortReinstallMachineParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.AbortReinstallMachineOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.AbortReinstallMachineOK
	if rf, ok := ret.Get(0).(func(*operations.AbortReinstallMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.AbortReinstallMachineOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.AbortReinstallMachineOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.AbortReinstallMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddProvisioningEvent provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AddProvisioningEvent(params *operations.AddProvisioningEventParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.AddProvisioningEventOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.AddProvisioningEventOK
	if rf, ok := ret.Get(0).(func(*operations.AddProvisioningEventParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.AddProvisioningEventOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.AddProvisioningEventOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.AddProvisioningEventParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllocateFirewall provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AllocateFirewall(params *operations.AllocateFirewallParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.AllocateFirewallOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.AllocateFirewallOK
	if rf, ok := ret.Get(0).(func(*operations.AllocateFirewallParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.AllocateFirewallOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.AllocateFirewallOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.AllocateFirewallParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllocateIP provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AllocateIP(params *operations.AllocateIPParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.AllocateIPCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.AllocateIPCreated
	if rf, ok := ret.Get(0).(func(*operations.AllocateIPParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.AllocateIPCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.AllocateIPCreated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.AllocateIPParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllocateMachine provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AllocateMachine(params *operations.AllocateMachineParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.AllocateMachineOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.AllocateMachineOK
	if rf, ok := ret.Get(0).(func(*operations.AllocateMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.AllocateMachineOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.AllocateMachineOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.AllocateMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllocateNetwork provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AllocateNetwork(params *operations.AllocateNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.AllocateNetworkCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.AllocateNetworkCreated
	if rf, ok := ret.Get(0).(func(*operations.AllocateNetworkParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.AllocateNetworkCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.AllocateNetworkCreated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.AllocateNetworkParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AllocateSpecificIP provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) AllocateSpecificIP(params *operations.AllocateSpecificIPParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.AllocateSpecificIPCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.AllocateSpecificIPCreated
	if rf, ok := ret.Get(0).(func(*operations.AllocateSpecificIPParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.AllocateSpecificIPCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.AllocateSpecificIPCreated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.AllocateSpecificIPParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChassisIdentifyLEDOff provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ChassisIdentifyLEDOff(params *operations.ChassisIdentifyLEDOffParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ChassisIdentifyLEDOffOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ChassisIdentifyLEDOffOK
	if rf, ok := ret.Get(0).(func(*operations.ChassisIdentifyLEDOffParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ChassisIdentifyLEDOffOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ChassisIdentifyLEDOffOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ChassisIdentifyLEDOffParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChassisIdentifyLEDOn provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ChassisIdentifyLEDOn(params *operations.ChassisIdentifyLEDOnParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ChassisIdentifyLEDOnOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ChassisIdentifyLEDOnOK
	if rf, ok := ret.Get(0).(func(*operations.ChassisIdentifyLEDOnParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ChassisIdentifyLEDOnOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ChassisIdentifyLEDOnOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ChassisIdentifyLEDOnParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFilesystemLayout provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CreateFilesystemLayout(params *operations.CreateFilesystemLayoutParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.CreateFilesystemLayoutCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.CreateFilesystemLayoutCreated
	if rf, ok := ret.Get(0).(func(*operations.CreateFilesystemLayoutParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.CreateFilesystemLayoutCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.CreateFilesystemLayoutCreated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.CreateFilesystemLayoutParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateImage provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CreateImage(params *operations.CreateImageParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.CreateImageCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.CreateImageCreated
	if rf, ok := ret.Get(0).(func(*operations.CreateImageParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.CreateImageCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.CreateImageCreated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.CreateImageParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNetwork provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CreateNetwork(params *operations.CreateNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.CreateNetworkCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.CreateNetworkCreated
	if rf, ok := ret.Get(0).(func(*operations.CreateNetworkParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.CreateNetworkCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.CreateNetworkCreated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.CreateNetworkParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreatePartition provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CreatePartition(params *operations.CreatePartitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.CreatePartitionCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.CreatePartitionCreated
	if rf, ok := ret.Get(0).(func(*operations.CreatePartitionParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.CreatePartitionCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.CreatePartitionCreated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.CreatePartitionParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProject provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CreateProject(params *operations.CreateProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.CreateProjectCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.CreateProjectCreated
	if rf, ok := ret.Get(0).(func(*operations.CreateProjectParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.CreateProjectCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.CreateProjectCreated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.CreateProjectParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateSize provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) CreateSize(params *operations.CreateSizeParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.CreateSizeCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.CreateSizeCreated
	if rf, ok := ret.Get(0).(func(*operations.CreateSizeParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.CreateSizeCreated); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.CreateSizeCreated)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.CreateSizeParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteFilesystemLayout provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DeleteFilesystemLayout(params *operations.DeleteFilesystemLayoutParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.DeleteFilesystemLayoutOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.DeleteFilesystemLayoutOK
	if rf, ok := ret.Get(0).(func(*operations.DeleteFilesystemLayoutParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.DeleteFilesystemLayoutOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.DeleteFilesystemLayoutOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.DeleteFilesystemLayoutParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteImage provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DeleteImage(params *operations.DeleteImageParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.DeleteImageOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.DeleteImageOK
	if rf, ok := ret.Get(0).(func(*operations.DeleteImageParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.DeleteImageOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.DeleteImageOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.DeleteImageParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMachine provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DeleteMachine(params *operations.DeleteMachineParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.DeleteMachineOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.DeleteMachineOK
	if rf, ok := ret.Get(0).(func(*operations.DeleteMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.DeleteMachineOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.DeleteMachineOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.DeleteMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteNetwork provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DeleteNetwork(params *operations.DeleteNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.DeleteNetworkOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.DeleteNetworkOK
	if rf, ok := ret.Get(0).(func(*operations.DeleteNetworkParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.DeleteNetworkOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.DeleteNetworkOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.DeleteNetworkParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePartition provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DeletePartition(params *operations.DeletePartitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.DeletePartitionOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.DeletePartitionOK
	if rf, ok := ret.Get(0).(func(*operations.DeletePartitionParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.DeletePartitionOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.DeletePartitionOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.DeletePartitionParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteProject provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DeleteProject(params *operations.DeleteProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.DeleteProjectOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.DeleteProjectOK
	if rf, ok := ret.Get(0).(func(*operations.DeleteProjectParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.DeleteProjectOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.DeleteProjectOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.DeleteProjectParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSize provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DeleteSize(params *operations.DeleteSizeParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.DeleteSizeOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.DeleteSizeOK
	if rf, ok := ret.Get(0).(func(*operations.DeleteSizeParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.DeleteSizeOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.DeleteSizeOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.DeleteSizeParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteSwitch provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) DeleteSwitch(params *operations.DeleteSwitchParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.DeleteSwitchOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.DeleteSwitchOK
	if rf, ok := ret.Get(0).(func(*operations.DeleteSwitchParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.DeleteSwitchOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.DeleteSwitchOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.DeleteSwitchParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FinalizeAllocation provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FinalizeAllocation(params *operations.FinalizeAllocationParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FinalizeAllocationOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FinalizeAllocationOK
	if rf, ok := ret.Get(0).(func(*operations.FinalizeAllocationParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FinalizeAllocationOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FinalizeAllocationOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FinalizeAllocationParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindFirewall provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindFirewall(params *operations.FindFirewallParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindFirewallOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindFirewallOK
	if rf, ok := ret.Get(0).(func(*operations.FindFirewallParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindFirewallOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindFirewallOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindFirewallParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindFirewalls provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindFirewalls(params *operations.FindFirewallsParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindFirewallsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindFirewallsOK
	if rf, ok := ret.Get(0).(func(*operations.FindFirewallsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindFirewallsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindFirewallsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindFirewallsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindIP provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindIP(params *operations.FindIPParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindIPOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindIPOK
	if rf, ok := ret.Get(0).(func(*operations.FindIPParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindIPOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindIPOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindIPParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindIPMIMachine provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindIPMIMachine(params *operations.FindIPMIMachineParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindIPMIMachineOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindIPMIMachineOK
	if rf, ok := ret.Get(0).(func(*operations.FindIPMIMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindIPMIMachineOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindIPMIMachineOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindIPMIMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindIPMIMachines provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindIPMIMachines(params *operations.FindIPMIMachinesParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindIPMIMachinesOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindIPMIMachinesOK
	if rf, ok := ret.Get(0).(func(*operations.FindIPMIMachinesParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindIPMIMachinesOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindIPMIMachinesOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindIPMIMachinesParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindIPs provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindIPs(params *operations.FindIPsParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindIPsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindIPsOK
	if rf, ok := ret.Get(0).(func(*operations.FindIPsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindIPsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindIPsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindIPsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindImage provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindImage(params *operations.FindImageParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindImageOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindImageOK
	if rf, ok := ret.Get(0).(func(*operations.FindImageParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindImageOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindImageOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindImageParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindLatestImage provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindLatestImage(params *operations.FindLatestImageParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindLatestImageOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindLatestImageOK
	if rf, ok := ret.Get(0).(func(*operations.FindLatestImageParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindLatestImageOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindLatestImageOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindLatestImageParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindMachine provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindMachine(params *operations.FindMachineParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindMachineOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindMachineOK
	if rf, ok := ret.Get(0).(func(*operations.FindMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindMachineOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindMachineOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindMachines provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindMachines(params *operations.FindMachinesParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindMachinesOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindMachinesOK
	if rf, ok := ret.Get(0).(func(*operations.FindMachinesParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindMachinesOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindMachinesOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindMachinesParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindNetwork provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindNetwork(params *operations.FindNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindNetworkOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindNetworkOK
	if rf, ok := ret.Get(0).(func(*operations.FindNetworkParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindNetworkOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindNetworkOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindNetworkParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindNetworks provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindNetworks(params *operations.FindNetworksParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindNetworksOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindNetworksOK
	if rf, ok := ret.Get(0).(func(*operations.FindNetworksParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindNetworksOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindNetworksOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindNetworksParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindPartition provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindPartition(params *operations.FindPartitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindPartitionOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindPartitionOK
	if rf, ok := ret.Get(0).(func(*operations.FindPartitionParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindPartitionOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindPartitionOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindPartitionParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindProject provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindProject(params *operations.FindProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindProjectOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindProjectOK
	if rf, ok := ret.Get(0).(func(*operations.FindProjectParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindProjectOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindProjectOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindProjectParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindProjects provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindProjects(params *operations.FindProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindProjectsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindProjectsOK
	if rf, ok := ret.Get(0).(func(*operations.FindProjectsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindProjectsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindProjectsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindProjectsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindSize provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindSize(params *operations.FindSizeParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindSizeOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindSizeOK
	if rf, ok := ret.Get(0).(func(*operations.FindSizeParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindSizeOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindSizeOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindSizeParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindSwitch provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FindSwitch(params *operations.FindSwitchParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FindSwitchOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FindSwitchOK
	if rf, ok := ret.Get(0).(func(*operations.FindSwitchParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FindSwitchOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FindSwitchOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FindSwitchParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FreeIP provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FreeIP(params *operations.FreeIPParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FreeIPOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FreeIPOK
	if rf, ok := ret.Get(0).(func(*operations.FreeIPParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FreeIPOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FreeIPOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FreeIPParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FreeMachine provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FreeMachine(params *operations.FreeMachineParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FreeMachineOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FreeMachineOK
	if rf, ok := ret.Get(0).(func(*operations.FreeMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FreeMachineOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FreeMachineOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FreeMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FreeNetwork provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FreeNetwork(params *operations.FreeNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FreeNetworkOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FreeNetworkOK
	if rf, ok := ret.Get(0).(func(*operations.FreeNetworkParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FreeNetworkOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FreeNetworkOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FreeNetworkParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FromHardware provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) FromHardware(params *operations.FromHardwareParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.FromHardwareOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.FromHardwareOK
	if rf, ok := ret.Get(0).(func(*operations.FromHardwareParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.FromHardwareOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.FromHardwareOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.FromHardwareParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFilesystemLayout provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetFilesystemLayout(params *operations.GetFilesystemLayoutParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.GetFilesystemLayoutOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.GetFilesystemLayoutOK
	if rf, ok := ret.Get(0).(func(*operations.GetFilesystemLayoutParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.GetFilesystemLayoutOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.GetFilesystemLayoutOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.GetFilesystemLayoutParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMachineConsolePassword provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetMachineConsolePassword(params *operations.GetMachineConsolePasswordParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.GetMachineConsolePasswordOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.GetMachineConsolePasswordOK
	if rf, ok := ret.Get(0).(func(*operations.GetMachineConsolePasswordParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.GetMachineConsolePasswordOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.GetMachineConsolePasswordOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.GetMachineConsolePasswordParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMe provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetMe(params *operations.GetMeParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.GetMeOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.GetMeOK
	if rf, ok := ret.Get(0).(func(*operations.GetMeParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.GetMeOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.GetMeOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.GetMeParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProvisioningEventContainer provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetProvisioningEventContainer(params *operations.GetProvisioningEventContainerParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.GetProvisioningEventContainerOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.GetProvisioningEventContainerOK
	if rf, ok := ret.Get(0).(func(*operations.GetProvisioningEventContainerParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.GetProvisioningEventContainerOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.GetProvisioningEventContainerOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.GetProvisioningEventContainerParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTenant provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) GetTenant(params *operations.GetTenantParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.GetTenantOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.GetTenantOK
	if rf, ok := ret.Get(0).(func(*operations.GetTenantParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.GetTenantOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.GetTenantOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.GetTenantParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Health provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) Health(params *operations.HealthParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.HealthOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.HealthOK
	if rf, ok := ret.Get(0).(func(*operations.HealthParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.HealthOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.HealthOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.HealthParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Info provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) Info(params *operations.InfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.InfoOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.InfoOK
	if rf, ok := ret.Get(0).(func(*operations.InfoParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.InfoOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.InfoOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.InfoParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IpmiReport provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) IpmiReport(params *operations.IpmiReportParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.IpmiReportOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.IpmiReportOK
	if rf, ok := ret.Get(0).(func(*operations.IpmiReportParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.IpmiReportOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.IpmiReportOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.IpmiReportParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFilesystemLayouts provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListFilesystemLayouts(params *operations.ListFilesystemLayoutsParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ListFilesystemLayoutsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ListFilesystemLayoutsOK
	if rf, ok := ret.Get(0).(func(*operations.ListFilesystemLayoutsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ListFilesystemLayoutsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ListFilesystemLayoutsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ListFilesystemLayoutsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFirewalls provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListFirewalls(params *operations.ListFirewallsParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ListFirewallsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ListFirewallsOK
	if rf, ok := ret.Get(0).(func(*operations.ListFirewallsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ListFirewallsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ListFirewallsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ListFirewallsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFirmwares provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListFirmwares(params *operations.ListFirmwaresParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ListFirmwaresOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ListFirmwaresOK
	if rf, ok := ret.Get(0).(func(*operations.ListFirmwaresParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ListFirmwaresOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ListFirmwaresOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ListFirmwaresParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListIPs provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListIPs(params *operations.ListIPsParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ListIPsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ListIPsOK
	if rf, ok := ret.Get(0).(func(*operations.ListIPsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ListIPsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ListIPsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ListIPsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListImages provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListImages(params *operations.ListImagesParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ListImagesOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ListImagesOK
	if rf, ok := ret.Get(0).(func(*operations.ListImagesParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ListImagesOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ListImagesOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ListImagesParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMachines provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListMachines(params *operations.ListMachinesParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ListMachinesOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ListMachinesOK
	if rf, ok := ret.Get(0).(func(*operations.ListMachinesParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ListMachinesOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ListMachinesOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ListMachinesParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNetworks provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListNetworks(params *operations.ListNetworksParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ListNetworksOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ListNetworksOK
	if rf, ok := ret.Get(0).(func(*operations.ListNetworksParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ListNetworksOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ListNetworksOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ListNetworksParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPartitions provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListPartitions(params *operations.ListPartitionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ListPartitionsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ListPartitionsOK
	if rf, ok := ret.Get(0).(func(*operations.ListPartitionsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ListPartitionsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ListPartitionsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ListPartitionsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListProjects provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListProjects(params *operations.ListProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ListProjectsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ListProjectsOK
	if rf, ok := ret.Get(0).(func(*operations.ListProjectsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ListProjectsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ListProjectsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ListProjectsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSizes provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListSizes(params *operations.ListSizesParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ListSizesOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ListSizesOK
	if rf, ok := ret.Get(0).(func(*operations.ListSizesParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ListSizesOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ListSizesOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ListSizesParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSwitches provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListSwitches(params *operations.ListSwitchesParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ListSwitchesOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ListSwitchesOK
	if rf, ok := ret.Get(0).(func(*operations.ListSwitchesParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ListSwitchesOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ListSwitchesOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ListSwitchesParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTenants provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ListTenants(params *operations.ListTenantsParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ListTenantsOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ListTenantsOK
	if rf, ok := ret.Get(0).(func(*operations.ListTenantsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ListTenantsOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ListTenantsOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ListTenantsParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MachineBios provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MachineBios(params *operations.MachineBiosParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.MachineBiosOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.MachineBiosOK
	if rf, ok := ret.Get(0).(func(*operations.MachineBiosParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.MachineBiosOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.MachineBiosOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.MachineBiosParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MachineCycle provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MachineCycle(params *operations.MachineCycleParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.MachineCycleOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.MachineCycleOK
	if rf, ok := ret.Get(0).(func(*operations.MachineCycleParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.MachineCycleOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.MachineCycleOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.MachineCycleParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MachineDisk provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MachineDisk(params *operations.MachineDiskParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.MachineDiskOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.MachineDiskOK
	if rf, ok := ret.Get(0).(func(*operations.MachineDiskParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.MachineDiskOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.MachineDiskOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.MachineDiskParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MachineOff provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MachineOff(params *operations.MachineOffParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.MachineOffOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.MachineOffOK
	if rf, ok := ret.Get(0).(func(*operations.MachineOffParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.MachineOffOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.MachineOffOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.MachineOffParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MachineOn provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MachineOn(params *operations.MachineOnParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.MachineOnOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.MachineOnOK
	if rf, ok := ret.Get(0).(func(*operations.MachineOnParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.MachineOnOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.MachineOnOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.MachineOnParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MachinePxe provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MachinePxe(params *operations.MachinePxeParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.MachinePxeOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.MachinePxeOK
	if rf, ok := ret.Get(0).(func(*operations.MachinePxeParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.MachinePxeOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.MachinePxeOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.MachinePxeParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MachineReset provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MachineReset(params *operations.MachineResetParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.MachineResetOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.MachineResetOK
	if rf, ok := ret.Get(0).(func(*operations.MachineResetParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.MachineResetOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.MachineResetOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.MachineResetParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MatchFilesystemLayout provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) MatchFilesystemLayout(params *operations.MatchFilesystemLayoutParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.MatchFilesystemLayoutOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.MatchFilesystemLayoutOK
	if rf, ok := ret.Get(0).(func(*operations.MatchFilesystemLayoutParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.MatchFilesystemLayoutOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.MatchFilesystemLayoutOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.MatchFilesystemLayoutParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NotifySwitch provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) NotifySwitch(params *operations.NotifySwitchParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.NotifySwitchOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.NotifySwitchOK
	if rf, ok := ret.Get(0).(func(*operations.NotifySwitchParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.NotifySwitchOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.NotifySwitchOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.NotifySwitchParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PartitionCapacity provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) PartitionCapacity(params *operations.PartitionCapacityParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.PartitionCapacityOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.PartitionCapacityOK
	if rf, ok := ret.Get(0).(func(*operations.PartitionCapacityParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.PartitionCapacityOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.PartitionCapacityOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.PartitionCapacityParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryImagesByID provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) QueryImagesByID(params *operations.QueryImagesByIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.QueryImagesByIDOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.QueryImagesByIDOK
	if rf, ok := ret.Get(0).(func(*operations.QueryImagesByIDParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.QueryImagesByIDOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.QueryImagesByIDOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.QueryImagesByIDParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterMachine provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RegisterMachine(params *operations.RegisterMachineParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.RegisterMachineOK, *operations.RegisterMachineCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.RegisterMachineOK
	if rf, ok := ret.Get(0).(func(*operations.RegisterMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.RegisterMachineOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.RegisterMachineOK)
		}
	}

	var r1 *operations.RegisterMachineCreated
	if rf, ok := ret.Get(1).(func(*operations.RegisterMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.RegisterMachineCreated); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*operations.RegisterMachineCreated)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*operations.RegisterMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RegisterSwitch provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RegisterSwitch(params *operations.RegisterSwitchParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.RegisterSwitchOK, *operations.RegisterSwitchCreated, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.RegisterSwitchOK
	if rf, ok := ret.Get(0).(func(*operations.RegisterSwitchParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.RegisterSwitchOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.RegisterSwitchOK)
		}
	}

	var r1 *operations.RegisterSwitchCreated
	if rf, ok := ret.Get(1).(func(*operations.RegisterSwitchParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.RegisterSwitchCreated); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*operations.RegisterSwitchCreated)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*operations.RegisterSwitchParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r2 = rf(params, authInfo, opts...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ReinstallMachine provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) ReinstallMachine(params *operations.ReinstallMachineParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.ReinstallMachineOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.ReinstallMachineOK
	if rf, ok := ret.Get(0).(func(*operations.ReinstallMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.ReinstallMachineOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.ReinstallMachineOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.ReinstallMachineParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveFirmware provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) RemoveFirmware(params *operations.RemoveFirmwareParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.RemoveFirmwareOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.RemoveFirmwareOK
	if rf, ok := ret.Get(0).(func(*operations.RemoveFirmwareParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.RemoveFirmwareOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.RemoveFirmwareOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.RemoveFirmwareParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetChassisIdentifyLEDState provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SetChassisIdentifyLEDState(params *operations.SetChassisIdentifyLEDStateParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.SetChassisIdentifyLEDStateOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.SetChassisIdentifyLEDStateOK
	if rf, ok := ret.Get(0).(func(*operations.SetChassisIdentifyLEDStateParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.SetChassisIdentifyLEDStateOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.SetChassisIdentifyLEDStateOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.SetChassisIdentifyLEDStateParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetMachineState provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) SetMachineState(params *operations.SetMachineStateParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.SetMachineStateOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.SetMachineStateOK
	if rf, ok := ret.Get(0).(func(*operations.SetMachineStateParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.SetMachineStateOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.SetMachineStateOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.SetMachineStateParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetTransport provides a mock function with given fields: transport
func (_m *ClientService) SetTransport(transport runtime.ClientTransport) {
	_m.Called(transport)
}

// TryFilesystemLayout provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) TryFilesystemLayout(params *operations.TryFilesystemLayoutParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.TryFilesystemLayoutOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.TryFilesystemLayoutOK
	if rf, ok := ret.Get(0).(func(*operations.TryFilesystemLayoutParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.TryFilesystemLayoutOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.TryFilesystemLayoutOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.TryFilesystemLayoutParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFilesystemLayout provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdateFilesystemLayout(params *operations.UpdateFilesystemLayoutParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.UpdateFilesystemLayoutOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.UpdateFilesystemLayoutOK
	if rf, ok := ret.Get(0).(func(*operations.UpdateFilesystemLayoutParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.UpdateFilesystemLayoutOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.UpdateFilesystemLayoutOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.UpdateFilesystemLayoutParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFirmware provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdateFirmware(params *operations.UpdateFirmwareParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.UpdateFirmwareOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.UpdateFirmwareOK
	if rf, ok := ret.Get(0).(func(*operations.UpdateFirmwareParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.UpdateFirmwareOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.UpdateFirmwareOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.UpdateFirmwareParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateIP provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdateIP(params *operations.UpdateIPParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.UpdateIPOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.UpdateIPOK
	if rf, ok := ret.Get(0).(func(*operations.UpdateIPParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.UpdateIPOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.UpdateIPOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.UpdateIPParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateImage provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdateImage(params *operations.UpdateImageParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.UpdateImageOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.UpdateImageOK
	if rf, ok := ret.Get(0).(func(*operations.UpdateImageParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.UpdateImageOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.UpdateImageOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.UpdateImageParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateNetwork provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdateNetwork(params *operations.UpdateNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.UpdateNetworkOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.UpdateNetworkOK
	if rf, ok := ret.Get(0).(func(*operations.UpdateNetworkParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.UpdateNetworkOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.UpdateNetworkOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.UpdateNetworkParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePartition provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdatePartition(params *operations.UpdatePartitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.UpdatePartitionOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.UpdatePartitionOK
	if rf, ok := ret.Get(0).(func(*operations.UpdatePartitionParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.UpdatePartitionOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.UpdatePartitionOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.UpdatePartitionParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateProject provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdateProject(params *operations.UpdateProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.UpdateProjectOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.UpdateProjectOK
	if rf, ok := ret.Get(0).(func(*operations.UpdateProjectParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.UpdateProjectOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.UpdateProjectOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.UpdateProjectParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSize provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdateSize(params *operations.UpdateSizeParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.UpdateSizeOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.UpdateSizeOK
	if rf, ok := ret.Get(0).(func(*operations.UpdateSizeParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.UpdateSizeOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.UpdateSizeOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.UpdateSizeParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateSwitch provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UpdateSwitch(params *operations.UpdateSwitchParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.UpdateSwitchOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.UpdateSwitchOK
	if rf, ok := ret.Get(0).(func(*operations.UpdateSwitchParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.UpdateSwitchOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.UpdateSwitchOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.UpdateSwitchParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UploadFirmware provides a mock function with given fields: params, authInfo, opts
func (_m *ClientService) UploadFirmware(params *operations.UploadFirmwareParams, authInfo runtime.ClientAuthInfoWriter, opts ...operations.ClientOption) (*operations.UploadFirmwareOK, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, params, authInfo)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *operations.UploadFirmwareOK
	if rf, ok := ret.Get(0).(func(*operations.UploadFirmwareParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) *operations.UploadFirmwareOK); ok {
		r0 = rf(params, authInfo, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*operations.UploadFirmwareOK)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*operations.UploadFirmwareParams, runtime.ClientAuthInfoWriter, ...operations.ClientOption) error); ok {
		r1 = rf(params, authInfo, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
